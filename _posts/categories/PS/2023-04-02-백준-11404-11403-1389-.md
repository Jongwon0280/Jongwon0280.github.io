
---
layout: single
title: 백준(11404, 11403, 1389)
categories:
  - PS
categories: PS
author_profile: true
toc: true
toc_label: "목록"
toc_icon: "bars"
toc_sticky: true
date: 2023-04-02
---
## 플로이드 알고리즘

### 플로이드(11404)

n(2 ≤ n ≤ 100)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있다. 각 버스는 한 번 사용할 때 필요한 비용이 있다.

모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.

- **입력**

첫째 줄에 도시의 개수 n이 주어지고 둘째 줄에는 버스의 개수 m이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 버스의 정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c로 이루어져 있다. 시작 도시와 도착 도시가 같은 경우는 없다. 비용은 100,000보다 작거나 같은 자연수이다.

시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.

- **입출력 예시**

```
5
14
1 2 2
1 3 3
1 4 1
1 5 10
2 4 2
3 4 1
3 5 1
4 5 3
3 5 10
3 1 8
1 4 2
5 1 7
3 4 2
5 2 4

--------------

0 2 3 1 4
12 0 15 2 5
8 5 0 1 1
10 7 13 0 3
7 4 10 6 0
```

### 해결책

이 문제는 출발지와 도착지가 정해진 최단경로 문제가 아닌 모든 경로에서의 최단경로를 구해야하는 문제이다. 그러므로 다익스트라알고리즘이 아닌 플로이드를 통해 답을 도출해낼 수 있다.

Floyd는 **dist[i][j] > dist[i][k] + dist[k][j]** 인 경우 최단경로를 수정하는 다이나믹프로그래밍 방식으로 n^3의 시간복잡도를 가지고 있다.

### 코드

```python
import sys
input = sys.stdin.readline

n = int(input())

m = int(input())

dist = [[sys.maxsize]*(n+1) for _ in range(n+1)]

for i in range(m):
    s,e,w = map(int,input().split())
    if dist[s][e] > w :
        dist[s][e] =w

for i in range(1,n+1):
    dist[i][i] = 0

for k in range(1,n+1):
    for i in range(1,n+1):
        for j in range(1,n+1):
            if dist[i][j] > dist[i][k]+dist[k][j]:
                dist[i][j] = dist[i][k]+dist[k][j]

for i in range(1,n+1):
    for j in range(1,n+1):
        if dist[i][j] == sys.maxsize :
            print(0,end=" ")
        else :
            print(dist[i][j],end=" ")
    print()
```

### 경로 찾기(11403)

가중치 없는 방향 그래프 G가 주어졌을 때, 모든 정점 (i, j)에 대해서, i에서 j로 가는 경로가 있는지 없는지 구하는 프로그램을 작성하시오.

- **입력**

첫째 줄에 정점의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄부터 N개 줄에는 그래프의 인접 행렬이 주어진다. i번째 줄의 j번째 숫자가 1인 경우에는 i에서 j로 가는 간선이 존재한다는 뜻이고, 0인 경우는 없다는 뜻이다. i번째 줄의 i번째 숫자는 항상 0이다.

- **입출력 예시**

```
3
0 1 0
0 0 1
1 0 0

--------------

1 1 1
1 1 1
1 1 1
```

### 해결책

이또한 위의 문제와 동일하지만 약간의 조건 변경이 필요하다. 가중치가 없는 단순 0,1을 구분하는 그래프이기에, 만일 dist[i][k] ==1 and dist[k][j] ==1 인 경우 dist[i][j]을 1로 초기화 해주는 식으로 문제를 해결하면 된다.

### 코드

```python
n = int(input())

dist = [[] for _ in range(n)]

for i in range(n):
    dist[i]=list(map(int,input().split()))

for k in range(n):
    for i in range(n):
        for j in range(n):
            if dist[i][j] != 1 :
                if dist[i][k] ==1 and dist[k][j]==1:
                    dist[i][j]=1

for i in range(n):
    for j in range(n):
        print(dist[i][j],end=" ")

    print()
```

### 케빈 베이컨의 6단계 법칙(1389)

케빈 베이컨의 6단계 법칙에 의하면 지구에 있는 모든 사람들은 최대 6단계 이내에서 서로 아는 사람으로 연결될 수 있다. 케빈 베이컨 게임은 임의의 두 사람이 최소 몇 단계 만에 이어질 수 있는지 계산하는 게임이다.

예를 들면, 전혀 상관없을 것 같은 인하대학교의 이강호와 서강대학교의 민세희는 몇 단계만에 이어질 수 있을까?

천민호는 이강호와 같은 학교에 다니는 사이이다. 천민호와 최백준은 Baekjoon Online Judge를 통해 알게 되었다. 최백준과 김선영은 같이 Startlink를 창업했다. 김선영과 김도현은 같은 학교 동아리 소속이다. 김도현과 민세희는 같은 학교에 다니는 사이로 서로 알고 있다. 즉, 이강호-천민호-최백준-김선영-김도현-민세희 와 같이 5단계만 거치면 된다.

케빈 베이컨은 미국 헐리우드 영화배우들 끼리 케빈 베이컨 게임을 했을때 나오는 단계의 총 합이 가장 적은 사람이라고 한다.

오늘은 Baekjoon Online Judge의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 찾으려고 한다. 케빈 베이컨 수는 모든 사람과 케빈 베이컨 게임을 했을 때, 나오는 단계의 합이다.

예를 들어, BOJ의 유저가 5명이고, 1과 3, 1과 4, 2와 3, 3과 4, 4와 5가 친구인 경우를 생각해보자.

1은 2까지 3을 통해 2단계 만에, 3까지 1단계, 4까지 1단계, 5까지 4를 통해서 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+1+2 = 6이다.

2는 1까지 3을 통해서 2단계 만에, 3까지 1단계 만에, 4까지 3을 통해서 2단계 만에, 5까지 3과 4를 통해서 3단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+2+3 = 8이다.

3은 1까지 1단계, 2까지 1단계, 4까지 1단계, 5까지 4를 통해 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 1+1+1+2 = 5이다.

4는 1까지 1단계, 2까지 3을 통해 2단계, 3까지 1단계, 5까지 1단계 만에 알 수 있다. 4의 케빈 베이컨의 수는 1+2+1+1 = 5가 된다.

마지막으로 5는 1까지 4를 통해 2단계, 2까지 4와 3을 통해 3단계, 3까지 4를 통해 2단계, 4까지 1단계 만에 알 수 있다. 5의 케빈 베이컨의 수는 2+3+2+1 = 8이다.

5명의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람은 3과 4이다.

BOJ 유저의 수와 친구 관계가 입력으로 주어졌을 때, 케빈 베이컨의 수가 가장 작은 사람을 구하는 프로그램을 작성하시오.

- **입력**

첫째 줄에 유저의 수 N (2 ≤ N ≤ 100)과 친구 관계의 수 M (1 ≤ M ≤ 5,000)이 주어진다. 둘째 줄부터 M개의 줄에는 친구 관계가 주어진다. 친구 관계는 A와 B로 이루어져 있으며, A와 B가 친구라는 뜻이다. A와 B가 친구이면, B와 A도 친구이며, A와 B가 같은 경우는 없다. 친구 관계는 중복되어 들어올 수도 있으며, 친구가 한 명도 없는 사람은 없다. 또, 모든 사람은 친구 관계로 연결되어져 있다. 사람의 번호는 1부터 N까지이며, 두 사람이 같은 번호를 갖는 경우는 없다.

- **출력**

첫째 줄에 BOJ의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 출력한다. 그런 사람이 여러 명일 경우에는 번호가 가장 작은 사람을 출력한다.

- **입출력 예시**

```
5 5
1 3
1 4
4 5
4 3
3 2

--------------

3
```

### 해결책

결론적으로 정리하면 케빈베이컨의 수라는 것은 각노드에서 출발해서 관계를 맺고있는 친구들과의 홉수를 세어서 더하는 것이라고 볼 수 있다.

위의 샘플을 통해 1번을 예시로 들면

1 → 3,4

2 → 3

3→ 1,2,4

4→ 3,5

5→ 4

다음과 같이 맺고있는데, 

2번 : 1→3→2(2번을 거쳐야 하므로 값은 2)

3번 : 1→3(값 :1)

4번 : 1→4(값 :1)

5번: 1→4→5(값:2)

2+1+1+2 = 6이다.

이런식으로 각각 노드들의 베이컨수를 구해서 가장작은 인덱스값을 출력해주면된다.

이 문제는 다양한 방법으로 풀이 할 수 있는데 필자는 BFS로 풀이하였다.

총 노드의 개수만큼 BFS를 수행하였고, 노드방식은 [ node번호, 카운팅숫자]로 구성하여, dequeue할때마다 카운팅 숫자를 누적해주는 방식으로 진행하였다. 누적한 값은 리스트에 append시켜줌으로써, 답을 도출 하였다.

### 코드

```python
import sys

from collections import deque

input = sys.stdin.readline

n ,m = map(int,input().split())

maps=[[] for _ in range(n+1)]

ans=[]

visited=[0]*(n+1)

def bfs(pnode,deq):
    global visited, maps

    deq.append([pnode,0])
    visited[pnode]=1
    sum=0

    while deq:
        node=deq.popleft()
        pr=node[0]
        weight = node[1]
        sum+=weight
        

        for index in maps[pr]:
            if not visited[index]:
                deq.append([index,weight+1])
                visited[index]=1
        
            
    return sum
    

for i in range(m):
    s,e=map(int,input().split())
    maps[s].append(e)
    maps[e].append(s)

for i in range(1,n+1):
    deq=deque([])
    ans.append(bfs(i,deq))
    visited=[0]*(n+1)

minval = sys.maxsize
answer = 0

for i in range(n):
    if minval>ans[i]:
        minval=ans[i]
        answer = i+1
print(answer)
```